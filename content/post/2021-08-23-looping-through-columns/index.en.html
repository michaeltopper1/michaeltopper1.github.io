---
title: Looping Through Columns (Without Looping)
author: R package build
date: '2021-08-23'
slug: looping-through-columns
categories:
  - datascience
  - R
  - cleaning
  - dplyr
tags:
  - tips
  - cleaning
  - wrangling
subtitle: ''
summary: 'Showcasing the power of `dplyr::across`!'
authors: []
lastmod: '2021-08-23T23:06:52-07:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
editor_options: 
  chunk_output_type: console
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>One of the most common wrangling problems I have to deal with is looping through columns of a dataframe/tibble. For instance, it is common that I want to create new columns that are a function of previous columns. To demonstrate this, I’ll use the <a href="https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-07-20/readme.md">Drought</a> data set from the TidyTuesdayR project. A description of the data is not too important for this post, as I will be strictly covering a mechanical tool. Let’s first load in the data. Note that I will be taking a random 10 rows of the data since it is quite large. There is no need to have the same set of random rows as me- this is simply for presentation purposes.</p>
<pre class="r"><code>## loading a couple packages I&#39;ll be using for cleaning
library(tidyverse)
library(lubridate)

## link
link &lt;- &quot;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-07-20/drought.csv&quot;

## load in the data
## get a random sample of the data and get rid of unnnecessary columns
drought &lt;- read_csv(link) %&gt;% 
  slice_sample(n = 10) %&gt;% 
  select(-map_date, -stat_fmt, -ends_with(&#39;total&#39;)) 

drought</code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_pct pop_pct
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;
##  1 SD        2004-06-22  2004-06-28 D0             10.5     3.48
##  2 NH        2002-12-10  2002-12-16 D0              0       0   
##  3 SD        2008-03-25  2008-03-31 D2             10.7     2.92
##  4 NJ        2010-05-11  2010-05-17 D2              0       0   
##  5 ME        2016-12-20  2016-12-26 D2             36.4    54.1 
##  6 MN        2002-04-02  2002-04-08 D4              0       0   
##  7 WY        2003-12-23  2003-12-29 D1              4.25   10.2 
##  8 UT        2019-04-23  2019-04-29 D3              0       0   
##  9 VA        2015-12-01  2015-12-07 D4              0       0   
## 10 MT        2003-06-17  2003-06-23 D1             27.0    26.9</code></pre>
<div id="looping-with-dplyracross" class="section level2">
<h2>Looping with <code>dplyr::across</code></h2>
<p>For the purpose of this post, let’s assume I want to do the following:</p>
<ol style="list-style-type: decimal">
<li><p>Change the <code>area_pct</code> and <code>pop_pct</code> columns to fractions and give them new names <code>area_frac</code> and <code>pop_frac</code>.</p></li>
<li><p>Make six new columns: columns named <code>valid_start_year</code>, <code>valid_start_month</code>, <code>valid_start_day</code> which is the year, month, and day of the column <code>valid_start</code> respectively, and columns named <code>valid_end_year</code>, <code>valid_end_month</code>, <code>valid_end_day</code> which is the year, month, and day of the column <code>valid_end_year</code> respectively.</p></li>
</ol>
<p>Each of these tasks, while generally tedious and requiring a lot of typing, can be done very quickly with minimal typing using the <code>dplyr::across</code> function.</p>
<div id="part-1-changing-from-percents-to-fractions." class="section level3">
<h3>Part 1: Changing from percents to fractions.</h3>
<p>Here’s how to complete task one. For demonstration purposes, I will display the code first, and explain afterwards.</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(.cols = c(area_pct, pop_pct), .fns = ~ ./100)) %&gt;% 
  rename(&quot;area_frac&quot; = &quot;area_pct&quot;, &quot;pop_frac&quot; = &quot;pop_pct&quot;) </code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_frac pop_frac
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;           &lt;dbl&gt;    &lt;dbl&gt;
##  1 SD        2004-06-22  2004-06-28 D0             0.105    0.0348
##  2 NH        2002-12-10  2002-12-16 D0             0        0     
##  3 SD        2008-03-25  2008-03-31 D2             0.107    0.0292
##  4 NJ        2010-05-11  2010-05-17 D2             0        0     
##  5 ME        2016-12-20  2016-12-26 D2             0.364    0.541 
##  6 MN        2002-04-02  2002-04-08 D4             0        0     
##  7 WY        2003-12-23  2003-12-29 D1             0.0425   0.102 
##  8 UT        2019-04-23  2019-04-29 D3             0        0     
##  9 VA        2015-12-01  2015-12-07 D4             0        0     
## 10 MT        2003-06-17  2003-06-23 D1             0.270    0.269</code></pre>
<p>Let’s break down the <code>dplyr::across</code> function. The <code>.cols</code> argument takes the columns you want to perform operations on, and the <code>.fns</code> takes the function you want to perform on the columns. In this case, I created a lambda function using the <code>~</code> character, and passed in each column to my function using the <code>.</code> character. Hence, this small lambda function is telling <code>R</code> to take each of the columns, and divide by 100.</p>
<p>While there is little coding involved in this solution, this can be made even more compact since the <code>.cols</code> argument can take the tidy selecting functions <code>starts_with</code> and <code>ends_with</code>. Watch as I trim down this code a little:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(ends_with(&quot;pct&quot;), ~ ./100)) %&gt;% 
  rename(&quot;area_frac&quot; = &quot;area_pct&quot;, &quot;pop_frac&quot; = &quot;pop_pct&quot;) </code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_frac pop_frac
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;           &lt;dbl&gt;    &lt;dbl&gt;
##  1 SD        2004-06-22  2004-06-28 D0             0.105    0.0348
##  2 NH        2002-12-10  2002-12-16 D0             0        0     
##  3 SD        2008-03-25  2008-03-31 D2             0.107    0.0292
##  4 NJ        2010-05-11  2010-05-17 D2             0        0     
##  5 ME        2016-12-20  2016-12-26 D2             0.364    0.541 
##  6 MN        2002-04-02  2002-04-08 D4             0        0     
##  7 WY        2003-12-23  2003-12-29 D1             0.0425   0.102 
##  8 UT        2019-04-23  2019-04-29 D3             0        0     
##  9 VA        2015-12-01  2015-12-07 D4             0        0     
## 10 MT        2003-06-17  2003-06-23 D1             0.270    0.269</code></pre>
<p>Here I operated my lambda function on all columns that ends with the phrase “pct”. You can imagine that this can become extremely powerful when scaled up.</p>
</div>
<div id="part-2-getting-month-and-year-columns" class="section level3">
<h3>Part 2: Getting month and year columns</h3>
<p>Now I want to achieve my second task. Here, I will showcase one of the most powerful arguments of <code>dplyr::across</code>: the <code>.names</code> argument. As before, let me first code a solution for demonstration:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(starts_with(&quot;valid&quot;), ~ year(.), .names = &quot;{.col}_year&quot;)) %&gt;% 
  select(-starts_with(&quot;area&quot;)) ## only doing this so that we can see the output easier</code></pre>
<pre><code>## # A tibble: 10 × 7
##    state_abb valid_start valid_end  drought_lvl pop_pct valid_start_year
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;         &lt;dbl&gt;            &lt;dbl&gt;
##  1 SD        2004-06-22  2004-06-28 D0             3.48             2004
##  2 NH        2002-12-10  2002-12-16 D0             0                2002
##  3 SD        2008-03-25  2008-03-31 D2             2.92             2008
##  4 NJ        2010-05-11  2010-05-17 D2             0                2010
##  5 ME        2016-12-20  2016-12-26 D2            54.1              2016
##  6 MN        2002-04-02  2002-04-08 D4             0                2002
##  7 WY        2003-12-23  2003-12-29 D1            10.2              2003
##  8 UT        2019-04-23  2019-04-29 D3             0                2019
##  9 VA        2015-12-01  2015-12-07 D4             0                2015
## 10 MT        2003-06-17  2003-06-23 D1            26.9              2003
## # … with 1 more variable: valid_end_year &lt;dbl&gt;</code></pre>
<p>As before, I am using a tidy select function <code>starts_with</code> to target the columns I want to operate on and perform a lambda function on each. However, you can see that I skipped a renaming step by using the <code>.names</code> argument. The <code>.names</code> argument has the special <code>glue</code> syntax (read more <a href="https://github.com/tidyverse/glue">here</a>). In particular, this means we can use <code>{.col}</code> to input in the original column name.</p>
<p>However, recall that I wanted 6 new columns, which would require me writing three separate <code>mutate</code> functions (or 3 big arguments passed into <code>mutate</code>) right? Nope! The <code>across</code> function’s <code>.fns</code> argument (which we passed our lambda function to) can actually take a list of functions. Observe:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(starts_with(&quot;valid&quot;), list(year = ~year(.), month = ~month(.), day = ~day(.)), .names = &quot;{.col}_{.fn}&quot;)) %&gt;% 
  select(starts_with(&quot;valid&quot;))</code></pre>
<pre><code>## # A tibble: 10 × 8
##    valid_start valid_end  valid_start_year valid_start_month valid_start_day
##    &lt;date&gt;      &lt;date&gt;                &lt;dbl&gt;             &lt;dbl&gt;           &lt;int&gt;
##  1 2004-06-22  2004-06-28             2004                 6              22
##  2 2002-12-10  2002-12-16             2002                12              10
##  3 2008-03-25  2008-03-31             2008                 3              25
##  4 2010-05-11  2010-05-17             2010                 5              11
##  5 2016-12-20  2016-12-26             2016                12              20
##  6 2002-04-02  2002-04-08             2002                 4               2
##  7 2003-12-23  2003-12-29             2003                12              23
##  8 2019-04-23  2019-04-29             2019                 4              23
##  9 2015-12-01  2015-12-07             2015                12               1
## 10 2003-06-17  2003-06-23             2003                 6              17
## # … with 3 more variables: valid_end_year &lt;dbl&gt;, valid_end_month &lt;dbl&gt;,
## #   valid_end_day &lt;int&gt;</code></pre>
<p>Notice what happened here: I passed in a named list of lambda functions to be performed on each of the columns. In effect, I performed the <code>lubridate::year</code>, <code>lubridate::month</code>, and <code>lubridate::day</code> functions on the columns of interest and achieved the goal of creating 6 different columns all with 1 line of code. Additionally, I used the special<code>{.fn}</code> character in the <code>.names</code> argument to pass in the name of each of the functions to the new column names. Pretty incredible isn’t it?</p>
</div>
</div>
