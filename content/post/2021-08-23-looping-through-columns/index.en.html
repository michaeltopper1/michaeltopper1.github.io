---
title: Looping Through Columns (Without Looping)
author: R package build
date: '2021-08-23'
slug: looping-through-columns
categories:
  - datascience
  - R
  - cleaning
  - dplyr
tags:
  - tips
  - cleaning
  - wrangling
subtitle: ''
summary: ''
authors: []
lastmod: '2021-08-23T23:06:52-07:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
editor_options: 
  chunk_output_type: console
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>One of the most common wrangling problems I have to deal with is looping through columns of a dataframe/tibble. For instance, it is common that I want to create new columns that are a function of previous columns. To demonstrate this, I’ll use the <a href="https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-07-20/readme.md">Drought</a> data set from the TidyTuesdayR project. A description of the data is not too important for this post, as I will be strictly covering a mechanical tool. Let’s first load in the data. Note that I will be taking a random 10 rows of the data since it is quite large. There is no need to have the same set of random rows as me- this is simply for presentation purposes.</p>
<pre class="r"><code>## loading a couple packages I&#39;ll be using for cleaning
library(tidyverse)
library(lubridate)

## link
link &lt;- &quot;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-07-20/drought.csv&quot;

## load in the data
## get a random sample of the data and get rid of unnnecessary columns
drought &lt;- read_csv(link) %&gt;% 
  slice_sample(n = 10) %&gt;% 
  select(-map_date, -stat_fmt, -ends_with(&#39;total&#39;)) 

drought</code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_pct pop_pct
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;
##  1 AL        2009-03-24  2009-03-30 None           27.3    40.7 
##  2 NC        2004-07-13  2004-07-19 D3              0       0   
##  3 MD        2017-10-17  2017-10-23 D3              0       0   
##  4 WI        2015-01-06  2015-01-12 D0              0       0   
##  5 KY        2019-05-14  2019-05-20 D2              0       0   
##  6 CT        2005-10-11  2005-10-17 D1              0       0   
##  7 NE        2004-09-07  2004-09-13 D4              0       0   
##  8 TN        2019-02-12  2019-02-18 D3              0       0   
##  9 UT        2019-02-26  2019-03-04 D2              3.98    0.65
## 10 NM        2002-11-05  2002-11-11 D0             11.1     7.58</code></pre>
<div id="looping-with-dplyracross" class="section level2">
<h2>Looping with <code>dplyr::across</code></h2>
<p>For the purpose of this post, let’s assume I want to do the following:</p>
<ol style="list-style-type: decimal">
<li><p>Change the <code>area_pct</code> and <code>pop_pct</code> columns to fractions and give them new names <code>area_frac</code> and <code>pop_frac</code>.</p></li>
<li><p>Make six new columns: columns named <code>valid_start_year</code>, <code>valid_start_month</code>, <code>valid_start_day</code> which is the year, month, and day of the column <code>valid_start</code> respectively, and columns named <code>valid_end_year</code>, <code>valid_end_month</code>, <code>valid_end_day</code> which is the year, month, and day of the column <code>valid_end_year</code> respectively.</p></li>
</ol>
<p>Each of these tasks, while generally tedious and requiring a lot of typing, can be done very quickly with minimal typing using the <code>dplyr::across</code> function.</p>
<div id="part-1-changing-from-percents-to-fractions." class="section level3">
<h3>Part 1: Changing from percents to fractions.</h3>
<p>Here’s how to complete task one. For demonstration purposes, I will display the code first, and explain afterwards.</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(.cols = c(area_pct, pop_pct), .fns = ~ ./100)) %&gt;% 
  rename(&quot;area_frac&quot; = &quot;area_pct&quot;, &quot;pop_frac&quot; = &quot;pop_pct&quot;) </code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_frac pop_frac
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;           &lt;dbl&gt;    &lt;dbl&gt;
##  1 AL        2009-03-24  2009-03-30 None           0.273    0.407 
##  2 NC        2004-07-13  2004-07-19 D3             0        0     
##  3 MD        2017-10-17  2017-10-23 D3             0        0     
##  4 WI        2015-01-06  2015-01-12 D0             0        0     
##  5 KY        2019-05-14  2019-05-20 D2             0        0     
##  6 CT        2005-10-11  2005-10-17 D1             0        0     
##  7 NE        2004-09-07  2004-09-13 D4             0        0     
##  8 TN        2019-02-12  2019-02-18 D3             0        0     
##  9 UT        2019-02-26  2019-03-04 D2             0.0398   0.0065
## 10 NM        2002-11-05  2002-11-11 D0             0.111    0.0758</code></pre>
<p>Let’s break down the <code>dplyr::across</code> function. The <code>.cols</code> argument takes the columns you want to perform operations on, and the <code>.fns</code> takes the function you want to perform on the columns. In this case, I created a lambda function using the <code>~</code> character, and passed in each column to my function using the <code>.</code> character. Hence, this small lambda function is telling <code>R</code> to take each of the columns, and divide by 100.</p>
<p>While there is little coding involved in this solution, this can be made even more compact since the <code>.cols</code> argument can take the tidy selecting functions <code>starts_with</code> and <code>ends_with</code>. Watch as I trim down this code a little:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(ends_with(&quot;pct&quot;), ~ ./100)) %&gt;% 
  rename(&quot;area_frac&quot; = &quot;area_pct&quot;, &quot;pop_frac&quot; = &quot;pop_pct&quot;) </code></pre>
<pre><code>## # A tibble: 10 × 6
##    state_abb valid_start valid_end  drought_lvl area_frac pop_frac
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;           &lt;dbl&gt;    &lt;dbl&gt;
##  1 AL        2009-03-24  2009-03-30 None           0.273    0.407 
##  2 NC        2004-07-13  2004-07-19 D3             0        0     
##  3 MD        2017-10-17  2017-10-23 D3             0        0     
##  4 WI        2015-01-06  2015-01-12 D0             0        0     
##  5 KY        2019-05-14  2019-05-20 D2             0        0     
##  6 CT        2005-10-11  2005-10-17 D1             0        0     
##  7 NE        2004-09-07  2004-09-13 D4             0        0     
##  8 TN        2019-02-12  2019-02-18 D3             0        0     
##  9 UT        2019-02-26  2019-03-04 D2             0.0398   0.0065
## 10 NM        2002-11-05  2002-11-11 D0             0.111    0.0758</code></pre>
<p>Here I operated my lambda function on all columns that ends with the phrase “pct”. You can imagine that this can become extremely powerful when scaled up.</p>
</div>
<div id="part-2-getting-month-and-year-columns" class="section level3">
<h3>Part 2: Getting month and year columns</h3>
<p>Now I want to achieve my second task. Here, I will showcase one of the most powerful arguments of <code>dplyr::across</code>: the <code>.names</code> argument. As before, let me first code a solution for demonstration:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(starts_with(&quot;valid&quot;), ~ year(.), .names = &quot;{.col}_year&quot;)) %&gt;% 
  select(-starts_with(&quot;area&quot;)) ## only doing this so that we can see the output easier</code></pre>
<pre><code>## # A tibble: 10 × 7
##    state_abb valid_start valid_end  drought_lvl pop_pct valid_start_year
##    &lt;chr&gt;     &lt;date&gt;      &lt;date&gt;     &lt;chr&gt;         &lt;dbl&gt;            &lt;dbl&gt;
##  1 AL        2009-03-24  2009-03-30 None          40.7              2009
##  2 NC        2004-07-13  2004-07-19 D3             0                2004
##  3 MD        2017-10-17  2017-10-23 D3             0                2017
##  4 WI        2015-01-06  2015-01-12 D0             0                2015
##  5 KY        2019-05-14  2019-05-20 D2             0                2019
##  6 CT        2005-10-11  2005-10-17 D1             0                2005
##  7 NE        2004-09-07  2004-09-13 D4             0                2004
##  8 TN        2019-02-12  2019-02-18 D3             0                2019
##  9 UT        2019-02-26  2019-03-04 D2             0.65             2019
## 10 NM        2002-11-05  2002-11-11 D0             7.58             2002
## # … with 1 more variable: valid_end_year &lt;dbl&gt;</code></pre>
<p>As before, I am using a tidy select function <code>starts_with</code> to target the columns I want to operate on and perform a lambda function on each. However, you can see that I skipped a renaming step by using the <code>.names</code> argument. The <code>.names</code> argument has the special <code>glue</code> syntax (read more <a href="https://github.com/tidyverse/glue">here</a>). In particular, this means we can use <code>{.col}</code> to input in the original column name.</p>
<p>However, recall that I wanted 6 new columns, which would require me writing three separate <code>mutate</code> functions (or 3 big arguments passed into <code>mutate</code>) right? Nope! The <code>across</code> function’s <code>.fns</code> argument (which we passed our lambda function to) can actually take a list of functions. Observe:</p>
<pre class="r"><code>drought %&gt;% 
  mutate(across(starts_with(&quot;valid&quot;), list(year = ~year(.), month = ~month(.), day = ~day(.)), .names = &quot;{.col}_{.fn}&quot;)) %&gt;% 
  select(starts_with(&quot;valid&quot;))</code></pre>
<pre><code>## # A tibble: 10 × 8
##    valid_start valid_end  valid_start_year valid_start_month valid_start_day
##    &lt;date&gt;      &lt;date&gt;                &lt;dbl&gt;             &lt;dbl&gt;           &lt;int&gt;
##  1 2009-03-24  2009-03-30             2009                 3              24
##  2 2004-07-13  2004-07-19             2004                 7              13
##  3 2017-10-17  2017-10-23             2017                10              17
##  4 2015-01-06  2015-01-12             2015                 1               6
##  5 2019-05-14  2019-05-20             2019                 5              14
##  6 2005-10-11  2005-10-17             2005                10              11
##  7 2004-09-07  2004-09-13             2004                 9               7
##  8 2019-02-12  2019-02-18             2019                 2              12
##  9 2019-02-26  2019-03-04             2019                 2              26
## 10 2002-11-05  2002-11-11             2002                11               5
## # … with 3 more variables: valid_end_year &lt;dbl&gt;, valid_end_month &lt;dbl&gt;,
## #   valid_end_day &lt;int&gt;</code></pre>
<p>Notice what happened here: I passed in a named list of lambda functions to be performed on each of the columns. In effect, I performed the <code>lubridate::year</code>, <code>lubridate::month</code>, and <code>lubridate::day</code> functions on the columns of interest and achieved the goal of creating 6 different columns all with 1 line of code. Additionally, I used the special<code>{.fn}</code> character in the <code>.names</code> argument to pass in the name of each of the functions to the new column names. Pretty incredible isn’t it?</p>
</div>
</div>
